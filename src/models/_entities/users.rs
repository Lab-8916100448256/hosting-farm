//! `SeaORM` Entity, @generated by sea-orm-codegen 1.0.0

use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "users")]
pub struct Model {
    pub created_at: DateTimeWithTimeZone,
    pub updated_at: DateTimeWithTimeZone,
    #[sea_orm(primary_key)]
    pub id: i32,
    pub pid: Uuid,
    #[sea_orm(unique)]
    pub email: String,
    pub password: String,
    #[sea_orm(unique)]
    pub api_key: String,
    pub name: String,
    pub reset_token: Option<String>,
    pub reset_sent_at: Option<DateTimeWithTimeZone>,
    pub email_verification_token: Option<String>,
    pub email_verification_sent_at: Option<DateTimeWithTimeZone>,
    pub email_verified_at: Option<DateTimeWithTimeZone>,
    pub magic_link_token: Option<String>,
    pub magic_link_expiration: Option<DateTimeWithTimeZone>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl Model {
    /// Get all teams that the user is a member of
    ///
    /// # Errors
    ///
    /// Returns an error if there's a database error
    pub async fn get_teams(&self, db: &DatabaseConnection) -> Result<Vec<crate::models::_entities::teams::Model>, DbErr> {
        use crate::models::_entities::{teams, team_memberships};
        use sea_orm::{JoinType, RelationTrait};

        // Query to get all teams where the user is a member
        let teams = teams::Entity::find()
            .join(
                JoinType::InnerJoin,
                teams::Entity::belongs_to(team_memberships::Entity)
                    .from(teams::Column::Id)
                    .to(team_memberships::Column::TeamId)
                    .into(),
            )
            .filter(team_memberships::Column::UserId.eq(self.id))
            .all(db)
            .await?;

        Ok(teams)
    }
}
